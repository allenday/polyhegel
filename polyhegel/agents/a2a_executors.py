"""
A2A AgentExecutor implementations for polyhegel agents

This module implements A2A AgentExecutor classes that wrap polyhegel's
existing agent functionality to work with the Agent2Agent protocol.
"""

import json
import logging
from typing import Any, Dict, List, Optional

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.utils import new_agent_text_message, new_data_artifact
from a2a.types import TaskState

from ..models import StrategicTheme, GenesisStrategy
from ..strategic_techniques import CLMMandate
from .base import AgentContext
from .leader import LeaderAgent
from .follower import FollowerAgent

logger = logging.getLogger(__name__)


class LeaderAgentExecutor(AgentExecutor):
    """
    A2A AgentExecutor implementation for polyhegel LeaderAgent
    
    Handles strategic theme generation requests using the A2A protocol.
    Maps A2A RequestContext to polyhegel AgentContext and streams results.
    """
    
    def __init__(self, model: Any, focus_mandates: Optional[List[CLMMandate]] = None, max_themes: int = 5):
        """
        Initialize LeaderAgent executor
        
        Args:
            model: pydantic-ai model instance
            focus_mandates: Optional list of CLM mandates to focus on
            max_themes: Maximum number of themes to generate
        """
        self.leader_agent = LeaderAgent(
            agent_id="a2a-leader",
            model=model,
            focus_mandates=focus_mandates,
            max_themes=max_themes
        )
        
    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Execute strategic theme generation
        
        Args:
            context: A2A request context containing user message
            event_queue: Queue for publishing response events
        """
        try:
            # Extract user input from A2A context
            user_input = context.get_user_input()
            if not user_input.strip():
                await event_queue.enqueue_event(
                    new_agent_text_message("Error: No strategic challenge provided")
                )
                return
            
            logger.info(f"Processing strategic theme generation request: {user_input[:100]}...")
            
            # Convert A2A context to polyhegel AgentContext
            agent_context = self._convert_to_agent_context(context, user_input)
            
            # Send initial acknowledgment
            await event_queue.enqueue_event(
                new_agent_text_message("ðŸŽ¯ Analyzing strategic challenge and generating themes...")
            )
            
            # Generate themes using polyhegel LeaderAgent
            themes = await self.leader_agent.generate_themes(agent_context)
            
            if not themes:
                await event_queue.enqueue_event(
                    new_agent_text_message("âš ï¸ No strategic themes could be generated for this challenge")
                )
                return
            
            # Stream individual theme results
            for i, theme in enumerate(themes, 1):
                theme_message = self._format_theme_message(theme, i, len(themes))
                await event_queue.enqueue_event(new_agent_text_message(theme_message))
            
            # Create structured data artifact with all themes
            themes_data = [theme.model_dump() for theme in themes]
            artifact = new_data_artifact(
                name=f"strategic_themes_{context.task_id}.json",
                data={"themes": themes_data, "total_count": len(themes)},
                description="Strategic themes generated by LeaderAgent"
            )
            await event_queue.enqueue_event(artifact)
            
            # Send completion message
            summary_message = self._create_summary_message(themes)
            await event_queue.enqueue_event(new_agent_text_message(summary_message))
            
            logger.info(f"Successfully generated {len(themes)} strategic themes")
            
        except Exception as e:
            logger.error(f"Error in LeaderAgent execution: {e}", exc_info=True)
            await event_queue.enqueue_event(
                new_agent_text_message(f"âŒ Error generating strategic themes: {str(e)}")
            )
    
    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Cancel theme generation task
        
        Args:
            context: A2A request context
            event_queue: Queue for publishing cancellation events
        """
        logger.info(f"Cancelling theme generation task {context.task_id}")
        await event_queue.enqueue_event(
            new_agent_text_message("ðŸš« Strategic theme generation cancelled")
        )
    
    def _convert_to_agent_context(self, context: RequestContext, user_input: str) -> AgentContext:
        """Convert A2A RequestContext to polyhegel AgentContext"""
        
        # Extract metadata if available
        metadata = context.metadata or {}
        
        return AgentContext(
            strategic_challenge=user_input,
            constraints=metadata.get("constraints", {}),
            objectives=metadata.get("objectives", []),
            stakeholders=metadata.get("stakeholders", []),
            timeline=metadata.get("timeline"),
            resources=metadata.get("resources", [])
        )
    
    def _format_theme_message(self, theme: StrategicTheme, index: int, total: int) -> str:
        """Format a strategic theme for streaming display"""
        
        primary_mandate = theme.get_primary_mandate()
        mandate_text = f" ({primary_mandate})" if primary_mandate else ""
        category_text = f" [{theme.category.value}]" if theme.category else ""
        
        message = f"## Theme {index}/{total}: {theme.title}{mandate_text}{category_text}\n\n"
        message += f"**Description:** {theme.description}\n\n"
        
        if hasattr(theme, 'key_concepts') and theme.key_concepts:
            message += "**Key Concepts:**\n"
            for concept in theme.key_concepts:
                message += f"â€¢ {concept}\n"
            message += "\n"
        
        if theme.clm_alignment:
            alignment_scores = []
            for mandate, score in theme.clm_alignment.items():
                if score >= 3.0:  # Only show significant alignments
                    alignment_scores.append(f"{mandate}: {score:.1f}")
            if alignment_scores:
                message += f"**CLM Alignment:** {', '.join(alignment_scores)}\n"
        
        return message
    
    def _create_summary_message(self, themes: List[StrategicTheme]) -> str:
        """Create final summary message"""
        
        message = f"âœ… **Strategic Theme Generation Complete**\n\n"
        message += f"Generated **{len(themes)}** strategic themes for analysis:\n\n"
        
        for i, theme in enumerate(themes, 1):
            primary_mandate = theme.get_primary_mandate()
            mandate_text = f" ({primary_mandate})" if primary_mandate else ""
            message += f"{i}. **{theme.title}**{mandate_text}\n"
        
        message += f"\nðŸ”„ **Next Step:** Use follower agents to develop detailed implementation strategies from these themes."
        
        return message


class FollowerAgentExecutor(AgentExecutor):
    """
    A2A AgentExecutor implementation for polyhegel FollowerAgent
    
    Handles detailed strategy development requests using the A2A protocol.
    Takes strategic themes and develops comprehensive implementation strategies.
    """
    
    def __init__(self, model: Any, specialization_mandate: Optional[CLMMandate] = None):
        """
        Initialize FollowerAgent executor
        
        Args:
            model: pydantic-ai model instance  
            specialization_mandate: CLM mandate specialization for this follower
        """
        self.follower_agent = FollowerAgent(
            agent_id="a2a-follower",
            model=model,
            specialization_mandate=specialization_mandate
        )
        
    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Execute strategy development from themes
        
        Args:
            context: A2A request context containing theme and user message
            event_queue: Queue for publishing response events
        """
        try:
            # Parse input - could be JSON theme or text description
            user_input = context.get_user_input()
            if not user_input.strip():
                await event_queue.enqueue_event(
                    new_agent_text_message("Error: No strategic theme or challenge provided")
                )
                return
            
            logger.info(f"Processing strategy development request: {user_input[:100]}...")
            
            # Try to parse as JSON theme, fallback to text
            theme, agent_context = self._parse_input_and_context(context, user_input)
            
            # Send initial acknowledgment
            specialization = self.follower_agent.specialization_mandate
            spec_text = f" ({specialization.value})" if specialization else ""
            await event_queue.enqueue_event(
                new_agent_text_message(f"âš™ï¸ Developing detailed strategy{spec_text}...")
            )
            
            # Develop strategy using polyhegel FollowerAgent
            strategy = await self.follower_agent.develop_strategy(theme, agent_context)
            
            if not strategy:
                await event_queue.enqueue_event(
                    new_agent_text_message("âš ï¸ Unable to develop strategy from provided input")
                )
                return
            
            # Stream strategy details
            strategy_message = self._format_strategy_message(strategy)
            await event_queue.enqueue_event(new_agent_text_message(strategy_message))
            
            # Create structured data artifact with strategy
            strategy_data = strategy.model_dump()
            artifact = new_data_artifact(
                name=f"detailed_strategy_{context.task_id}.json",
                data={"strategy": strategy_data},
                description="Detailed strategy developed by FollowerAgent"
            )
            await event_queue.enqueue_event(artifact)
            
            # Send completion message
            completion_message = f"âœ… **Strategy Development Complete**\n\n"
            completion_message += f"Generated detailed implementation strategy: **{strategy.title}**\n"
            completion_message += f"â€¢ {len(strategy.steps)} implementation steps\n"
            completion_message += f"â€¢ Timeline: {strategy.estimated_timeline}\n"
            if isinstance(strategy.alignment_score, dict):
                avg_score = sum(strategy.alignment_score.values()) / len(strategy.alignment_score)
                completion_message += f"â€¢ Average Alignment Score: {avg_score:.1f}\n"
            else:
                completion_message += f"â€¢ Alignment Score: {strategy.alignment_score:.1f}\n"
            
            await event_queue.enqueue_event(new_agent_text_message(completion_message))
            
            logger.info(f"Successfully developed strategy: {strategy.title}")
            
        except Exception as e:
            logger.error(f"Error in FollowerAgent execution: {e}", exc_info=True) 
            await event_queue.enqueue_event(
                new_agent_text_message(f"âŒ Error developing strategy: {str(e)}")
            )
    
    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Cancel strategy development task
        
        Args:
            context: A2A request context
            event_queue: Queue for publishing cancellation events
        """
        logger.info(f"Cancelling strategy development task {context.task_id}")
        await event_queue.enqueue_event(
            new_agent_text_message("ðŸš« Strategy development cancelled")
        )
    
    def _parse_input_and_context(self, context: RequestContext, user_input: str) -> tuple[StrategicTheme, AgentContext]:
        """Parse user input and extract theme + context"""
        
        metadata = context.metadata or {}
        
        # Try parsing as JSON first (theme from leader agent)
        try:
            data = json.loads(user_input)
            if "theme" in data:
                theme_data = data["theme"]
                theme = StrategicTheme(**theme_data)
                
                # Extract context from metadata or data
                context_data = data.get("context", {})
                agent_context = AgentContext(
                    strategic_challenge=context_data.get("strategic_challenge", theme.description),
                    constraints=context_data.get("constraints", {}),
                    objectives=context_data.get("objectives", []),
                    stakeholders=context_data.get("stakeholders", []),
                    timeline=context_data.get("timeline"),
                    resources=context_data.get("resources", [])
                )
                
                return theme, agent_context
                
        except (json.JSONDecodeError, KeyError, ValueError):
            pass
        
        # Fallback: create theme from text input
        theme = StrategicTheme(
            title="User-Provided Strategic Challenge",
            description=user_input,
            category=None,  # Will be inferred
            key_considerations=[],
            clm_alignment={}
        )
        
        agent_context = AgentContext(
            strategic_challenge=user_input,
            constraints=metadata.get("constraints", {}),
            objectives=metadata.get("objectives", []),
            stakeholders=metadata.get("stakeholders", []),
            timeline=metadata.get("timeline"),
            resources=metadata.get("resources", [])
        )
        
        return theme, agent_context
    
    def _format_strategy_message(self, strategy: GenesisStrategy) -> str:
        """Format strategy for streaming display"""
        
        message = f"## Strategy: {strategy.title}\n\n"
        if isinstance(strategy.alignment_score, dict):
            avg_score = sum(strategy.alignment_score.values()) / len(strategy.alignment_score)
            message += f"**Average Alignment Score:** {avg_score:.1f}/5.0\n"
        else:
            message += f"**Alignment Score:** {strategy.alignment_score:.1f}/5.0\n"
        message += f"**Timeline:** {strategy.estimated_timeline}\n\n"
        
        if strategy.resource_requirements:
            message += f"**Resource Requirements:** {', '.join(strategy.resource_requirements)}\n\n"
        
        message += f"**Implementation Steps ({len(strategy.steps)}):**\n\n"
        
        for i, step in enumerate(strategy.steps, 1):
            message += f"### Step {i}: {step.action}\n"
            message += f"**Outcome:** {step.outcome}\n"
            
            if step.prerequisites:
                message += f"**Prerequisites:** {', '.join(step.prerequisites)}\n"
            
            if step.risks:
                message += f"**Risks:** {', '.join(step.risks)}\n"
            
            if hasattr(step, 'confidence'):
                message += f"**Confidence:** {step.confidence:.1f}\n"
            
            message += "\n"
        
        return message